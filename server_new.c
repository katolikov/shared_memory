#include <sys/types.h>
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <string.h>
#include "shmem.h"


int main(){

      Message* msgptr;
      key_t key = 2002;
      int shmid, semid;
      FILE *g;
      int tail;
      char s[MAXBUFF];

      printf("\n\n\t\t\033[1;31mS\033[1;32mH\033[1;33mA\033[1;34mR\033[1;35mE\033[1;36mD\033[1;37m M\033[1;38mE\033[1;39mM\033[0;32mO\033[0;33mR\033[0;34mY\033[0m\n");
      printf("\n\033[1;35m[INFO]\033[0m \033[5mServer working.\033[0m\n");
      printf("\033[0m");
      /* Создадим область разделяемой памяти */
      // Этот системный вызов открывает разделяемую область памяти, идентификатор которой совпадает с key (1 арг),
      // и возвращает неотрицательный целочисленный дескриптор. Если значение key = IPC_PRIVATE,
      // системный вызов выделяет новую разделяемую область памяти, которая будет использоваться исключительно вызывающим процессом (родитель и сыновья).
      // Аргумент size (2 арг) задает размер разделяемой области памяти, которая может быть подсоединена к вызывающему процессу с помощью системного вызова shmat.
      // Если flag = 0  (3 арг) и нет разделяемой области памяти с идентификатором key, то этот системный вызов завершается неудачно, в противном случае он возвращает дескриптор этой области.
      // Если процессу необходимо создать разделяемую область памяти с ключом key, то значение flag должно представлять результат побитового сложения IPC_CREAT и прав доступа.
      if((shmid = shmget(key, sizeof(Message),PERM | IPC_CREAT)) < 0) {//возвращает дескриптор разделяемой памяти
          perror("\033[1;31m[ERROR] Can't create memory.");
          printf("\033[0m");
          return 1;
      }
        /* Присоединим ее */
        // shmat подсоединяет область разделяемой памяти, указанную shmid (1 арг), к виртуальному адресному пространству вызывающего процесса.
        // Процесс может затем читать данные из указанной области памяти и записывать в нее данные.
        // Если это вновь создаваемая область разделяемой памяти, то ядро реально выделяет область памяти только тогда, когда процесс вызывает этот системный вызов.
        // Аргумент addr (2) задает начальный виртуальный адрес адресного пространства вызывающего процесса, в которое необходимо отобразить разделяемую область памяти.
        // Если это значение равно 0, ядро может само найти в вызывающем процессе подходящий виртуальный адрес для отображения разделяемой области памяти.
        // Если значение addr = 0, flag (3) может содержать SHM_RND. Этот флаг указывает ядру на то, что виртуальный адрес addr можно округлить до границы страницы памяти.
        // В противном случае при addr ≠ 0, системный вызов завершается неудачно (-1).
        // Аргумент flag может иметь значение SHM_RDONLY, то есть процесс подсоединяется к разделяемой области памяти только для чтения.
        // Если этот флаг не установлен, то процесс может читать и писать в разделяемую область памяти с учетом разрешений на доступ, установленный создателем.
        // Системный вызов shmat возвращает виртуальный адрес области отображения разделяемой памяти, а в случае неудачи -1.
      if((msgptr = (Message*)shmat(shmid, 0, 0)) < 0) {
          perror("\033[1;31m[ERROR] Conneting error.");
          printf("\033[0m");
          return 1;
        }
        // Этот системный вызов открывает набор семафоров, идентификатор которого задан значением аргумента key(1),
        // и возвращает неотрицательный целочисленный дескриптор. Если key = (макрос) IPC_PRIVATE, системный вызов создает набор семафоров,
        // который будет использоваться исключительно вызывающим процессом для синхронизации родительского и порожденных процессов.
        // Если flag (3) = 0, системный вызов прерывает свою работу, если нет набора семафоров с идентификатором key;
        // в противном случае возвращает дескриптор этого набора семафоров. Если процессу необходимо создать новый набор с идентификатором key,
        // то значение flag должно представлять собой результат побитового сложения константы IPC_CREAT и числовых значений прав доступа для чтения и записи.
        // Значение num_sem(2) может быть равно нулю, если IPC_CREAT в flag не указан, или числу семафоров в создаваемом наборе.
      if((semid = semget(key, 1, PERM | IPC_CREAT)) < 0) {
          perror("\033[1;31m[ERROR] Can not creat sem.");
          printf("\033[0m");
          return 1;
        }

      g = popen("ps -A|grep 'tty'|awk '{print $1}'","r");

      if(!(g)){
           perror("\033[1;31m[ERROR] popen.");
           printf("\033[0m");
           return 1;
       }

       tail = fread(s, 1, sizeof(s), g);
       s[tail] = '\0';
       //printf("%s",s);
       strncpy(msgptr->buff, s, sizeof(s));
       pclose(g);
       /* блокируем*/
       // С помощью этого системного вызова можно изменять значение одного или нескольких семафоров в наборе с дескриптором semfd(1)
       // и/или проверять равенство их значений нулю. Аргумент op (2)— это указатель на массив объектов типа struct sembuf,
       // описанной в заголовке <sys/sem.h>, каждый из которых задает одну операцию (запрос или изменение значения).
       // len (3)— показывает, сколько элементов имеется в массиве, указанном op.
       if(semop(semid,lock,1) < 0){ //op – указатель на массив объектов 1 -  количество элиментов в массиве 1
            perror("\033[1;31m[ERROR] Can not wait client.");
            printf("\033[0m");
            return 1;
       }
       //схему добавить с семоф и один сем
       /* Отключимся от области */
       if(shmdt(msgptr) < 0){
            perror("\033[1;31m[ERROR] shmdt.");
            printf("\033[0m");
            return 1;
       }
       /* Удалим созданные объекты IPC */
       if(shmctl(shmid, IPC_RMID, 0) < 0) {
            perror("\033[1;31m[ERROR] Can not delete memory.");
            printf("\033[0m");
            return 1;
       }
       if(semctl(semid, 0, IPC_RMID) < 0) { //0 - индекс номер семафора
            perror("\033[1;31m[ERROR] Can not delete sem.");
            printf("\033[0m");
            return 1;
       }
       printf("\n\033[1;35m[INFO]\033[0m \033[5mClient stop working.\033[0m\n");
       printf("\033[0m");
       return 0;
}
